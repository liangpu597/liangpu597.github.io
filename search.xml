<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习TF坐标转换</title>
      <link href="/2020/07/15/%E5%AD%A6%E4%B9%A0TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E4%B8%8Eroslaunch%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/"/>
      <url>/2020/07/15/%E5%AD%A6%E4%B9%A0TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E4%B8%8Eroslaunch%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>在机器人系统中，我们经常会遇到坐标变换相关的问题。比如说，在一个导航系统中，我们通过激光雷达、双目摄像头等传感器对周围环境进行感知，但是这些传感器直接采集的数据是相对于传感器而言的， 而传感器在机器人身上的安装位置又各不相同，我们关心的则是外部环境与机器人本体之间的关系，所以还需要把相对于传感器的数据变换成为相对于机器人的数据。这个过程就是所谓的坐标变换。</p><p>如果涉及到多个机器人之间的协同工作，则需要维护两两之间的相对位置关系，在机器人很多的情况下，或者说是自由度很多的情况下，这种坐标系之间的变换关系就相对比较复杂。 ROS系统提供了一个叫做tf的坐标变换库，这个库使得我们能够在各种坐标系之间自由地切换。</p><p>在ROS中有一个turtle的例子，一个通过键盘控制turtle1跑，另外一个turtle2跟在turtle1后面，跟随其坐标进行跟踪。</p><a id="more"></a><p>这是：<a href="http://wiki.ros.org/tf/Tutorials/Introduction%20to%20tf" target="_blank" rel="noopener">官方例子</a></p><p>这一过程就是通过tf来实现的。一个tf系统由tf广播者(tf broadcaster)和tf监听者(tf listener)两个部分构成的。这里的白龟(turtle1)和红龟(turtle2)就是两个tf广播者，它们不断的向外发送自己相对于世界坐标系的位置。这里的是<font color=red>广播</font>，所以所有的都会接收到他们发送的。<br>另外有一个监听者负责维护两个乌龟的坐标系，通过tf的API系统计算白龟(turtle1)相对红龟(turtle2)的位置，并控制红龟(turtle2)跟踪白龟(turtle1)。</p><p><a href="http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28C%2B%2B%29" target="_blank" rel="noopener">官方broadcaster例子C++版</a></p><p>创建功能包及其依赖<br><code>catkin_create_pkg learning_tf tf roscpp rospy turtlesim</code></p><p>broadcaster.cpp，我们发布的节点就是通过这个来广播自己在世界坐标系的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里有我们访问master的接口</span><br><span class="line">#include &lt;ros&#x2F;ros.h&gt;     </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供了tf广播的各种API 后面的listen就是根据这个来的</span><br><span class="line">#include &lt;tf&#x2F;transform_broadcaster.h&gt;   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;turtlesim是一个依赖包，里面有将要订阅pose主题的消息类型</span><br><span class="line">#include &lt;turtlesim&#x2F;Pose.h&gt;</span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里的const turtlesim::PoseConstPtr&amp; msg 是一个套路，目前还不知道这个</span><br><span class="line">&#x2F;&#x2F;是啥意思？</span><br><span class="line">void poseCallback(const turtlesim::PoseConstPtr&amp; msg)&#123;</span><br><span class="line">  &#x2F;&#x2F;tf广播器</span><br><span class="line">  static tf::TransformBroadcaster br;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**根据乌龟当前的位姿，设置相对于世界坐标系的坐标变换</span><br><span class="line">  ** 位姿就是海龟仿真器发出的，也就是&#x2F;sim 这个sim就是海龟仿真器 &lt;node pkg&#x3D;&quot;turtlesim&quot; type&#x3D;&quot;turtlesim_node&quot; name&#x3D;&quot;sim&quot;&#x2F;&gt;</span><br><span class="line">  **这里启动时的名字</span><br><span class="line">  **&#x2F;</span><br><span class="line">  </span><br><span class="line">  tf::Transform transform;</span><br><span class="line">  transform.setOrigin( tf::Vector3(msg-&gt;x, msg-&gt;y, 0.0) );</span><br><span class="line">  tf::Quaternion q;</span><br><span class="line">  q.setRPY(0, 0, msg-&gt;theta);</span><br><span class="line">  transform.setRotation(q);</span><br><span class="line">  </span><br><span class="line">  &#x2F;**br有成员函数send**  这是 Transform自带的</span><br><span class="line">  ** 第一个参数是坐标变换内容，第二个参数是时间戳</span><br><span class="line">  ** world 和 turtle_name 表示本次坐标变换相对于世界坐标系的变换</span><br><span class="line">  &#x2F;</span><br><span class="line">  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;world&quot;, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化一个节点，名字叫做my_tf_broadcaster</span><br><span class="line">  ros::init(argc, argv, &quot;my_tf_broadcaster&quot;);</span><br><span class="line">  &#x2F;**输入参数有两个类似于这个:rosrun turtlesim turtle1  这个经过测试不行</span><br><span class="line">  **但是，rosrun turtlesim turtlsim_node 却是可以，不知道这里为什么</span><br><span class="line">  **所以，这里输入参数是2个，第二个参数就是turtle_name&#x2F;</span><br><span class="line">  if (argc !&#x3D; 2)&#123;ROS_ERROR(&quot;need turtle name as argument&quot;); return -1;&#125;;</span><br><span class="line">  turtle_name &#x3D; argv[1];</span><br><span class="line"></span><br><span class="line">  ros::NodeHandle node;</span><br><span class="line">  &#x2F;**这里turtle_name 就是：turtle1, turtle2</span><br><span class="line">  **这里&amp;poseCallback 前面可以不用加&amp;&#x2F;</span><br><span class="line">  ros::Subscriber sub &#x3D; node.subscribe(turtle_name+&quot;&#x2F;pose&quot;, 10, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;循环等待</span><br><span class="line">  ros::spin();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20listener%20%28C%2B%2B%29" target="_blank" rel="noopener">官方listener例子C++版</a></p><p>turtle_tf_listener.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros&#x2F;ros.h&gt;</span><br><span class="line">&#x2F;&#x2F;这里跟前面的不一样，前面是tf&#x2F;transform_broadcaster.h</span><br><span class="line">#include &lt;tf&#x2F;transform_listener.h&gt;  </span><br><span class="line">#include &lt;geometry_msgs&#x2F;Twist.h&gt;   &#x2F;&#x2F;坐标变换好像要用到这个</span><br><span class="line">#include &lt;turtlesim&#x2F;Spawn.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">  ros::init(argc, argv, &quot;my_tf_listener&quot;);</span><br><span class="line">  ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">  **这段就是在图中生成一个turtle,这里猜测，启动的时候已经启动了一个turtle1</span><br><span class="line">  **但是，还需要一个turtle2,所以这里生成一个</span><br><span class="line">  **但是，经过测试发现，这里的话，如果在后面设置的roslaunch 里面没有写的话</span><br><span class="line">  **那么就是只是生成一个turtle，而这个节点是没有启动的，那就更加不用说控制了</span><br><span class="line">  **同理，如果只是在roslaunch里面写了节点，这里不写的话，那么rosnode 里面会有</span><br><span class="line">  **但是，图中不会显示乌龟</span><br><span class="line">  *&#x2F;</span><br><span class="line">  ros::service::waitForService(&quot;spawn&quot;);</span><br><span class="line">  ros::ServiceClient add_turtle &#x3D;</span><br><span class="line">    node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;spawn&quot;);</span><br><span class="line">  turtlesim::Spawn srv;</span><br><span class="line">  add_turtle.call(srv);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前面是生成一个turtle2，然后我们要发布cmd_vel速度控制指令来控制</span><br><span class="line">  ros::Publisher turtle_vel &#x3D;</span><br><span class="line">    node.advertise&lt;geometry_msgs::Twist&gt;(&quot;turtle2&#x2F;cmd_vel&quot;, 10);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在程序中具现化监听器对象。只要创建了这个对象，它就开始监听系统中的各个坐标变换，并将之缓存10秒。</span><br><span class="line">  tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">  ros::Rate rate(10.0);</span><br><span class="line">  while (node.ok())&#123;</span><br><span class="line">    tf::StampedTransform transform;</span><br><span class="line">    try&#123;</span><br><span class="line">       &#x2F;**通过Transform的API 查询turtle2相对于turtle1的坐标变换</span><br><span class="line">        **第三个参数&#39;ros::Time(0)&#39;则指获取当前时刻的坐标关系。 最后一个参数**tranform则记录了具体的变换内容，它是一个tf::StampedTransform对象。</span><br><span class="line">        *&#x2F;</span><br><span class="line">      listener.lookupTransform(&quot;&#x2F;turtle2&quot;, &quot;&#x2F;turtle1&quot;,</span><br><span class="line">                               ros::Time(0), transform);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (tf::TransformException &amp;ex) &#123;</span><br><span class="line">      ROS_ERROR(&quot;%s&quot;,ex.what());</span><br><span class="line">      ros::Duration(1.0).sleep();</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;**监听到这两个的坐标变换后，得到turtle2关于turtle1的坐标变换后</span><br><span class="line">      **就可以计算turtle2的速度了，并发布速度指令控制其运动</span><br><span class="line">      **下面的这个还不知道是怎么计算的</span><br><span class="line">      *&#x2F;</span><br><span class="line">    geometry_msgs::Twist vel_msg;</span><br><span class="line">    vel_msg.angular.z &#x3D; 4.0 * atan2(transform.getOrigin().y(),</span><br><span class="line">                                    transform.getOrigin().x());</span><br><span class="line">    vel_msg.linear.x &#x3D; 0.5 * sqrt(pow(transform.getOrigin().x(), 2) +</span><br><span class="line">                                  pow(transform.getOrigin().y(), 2));</span><br><span class="line">    turtle_vel.publish(vel_msg);</span><br><span class="line"></span><br><span class="line">    rate.sleep();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，在learning_tf下新建launch文件turtle_tf_demo.launch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  &lt;launch&gt;</span><br><span class="line">    &lt;!-- 启动海龟仿真，光这一个就可以生成一个海龟turtle1--&gt;</span><br><span class="line">    &lt;node pkg&#x3D;&quot;turtlesim&quot; type&#x3D;&quot;turtlesim_node&quot; name&#x3D;&quot;sim&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 启动键盘控制海龟运动--&gt;</span><br><span class="line">    &lt;node pkg&#x3D;&quot;turtlesim&quot; type&#x3D;&quot;turtle_teleop_key&quot; name&#x3D;&quot;teleop&quot; output&#x3D;&quot;screen&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- Axes --&gt;</span><br><span class="line">    &lt;param name&#x3D;&quot;scale_linear&quot; value&#x3D;&quot;2&quot; type&#x3D;&quot;double&quot;&#x2F;&gt;</span><br><span class="line">    &lt;param name&#x3D;&quot;scale_angular&quot; value&#x3D;&quot;2&quot; type&#x3D;&quot;double&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 启动两个turtle的广播--&gt;</span><br><span class="line">&lt;!-- pkg是报名,type是boardcaster.cpp编译CMakeLists里面编译的可执行文件的名字--&gt;</span><br><span class="line">&lt;!-- args就是传递的参数--&gt;</span><br><span class="line">&lt;!-- name就是运行时节点的名字，本来一开始ros::init里面有名字，这里会把那个覆盖--&gt;</span><br><span class="line">&lt;!-- 但是，这里name也是必须的，不能删除，同时,ros::init初始化那里也不能删除</span><br><span class="line">感觉就是一个占位的，反正这里也会把它进行覆盖--&gt;</span><br><span class="line">    &lt;node pkg&#x3D;&quot;learning_tf&quot; type&#x3D;&quot;turtle_tf_broadcaster&quot;</span><br><span class="line">          args&#x3D;&quot;&#x2F;turtle1&quot; name&#x3D;&quot;turtle1_tf_broadcaster&quot; &#x2F;&gt;</span><br><span class="line">    &lt;node pkg&#x3D;&quot;learning_tf&quot; type&#x3D;&quot;turtle_tf_broadcaster&quot;</span><br><span class="line">          args&#x3D;&quot;&#x2F;turtle2&quot; name&#x3D;&quot;turtle2_tf_broadcaster&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--启动监听节点，观察发现，这里就没有args参数，是因为这里不需要进行参数的传递前面是需要得到turtle在世界坐标系的位置并发布出去需要传递turtle的名字进去--&gt;</span><br><span class="line">    &lt;node pkg&#x3D;&quot;learning_tf&quot; type&#x3D;&quot;turtle_tf_listener&quot;</span><br><span class="line">          name&#x3D;&quot;listener&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;launch&gt;</span><br></pre></td></tr></table></figure><p>最后在CMakeLists.txt中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(turtle_tf_broadcaster src&#x2F;turtle_tf_broadcaster.cpp)</span><br><span class="line">target_link_libraries(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(turtle_tf_listener src&#x2F;turtle_tf_listener.cpp)</span><br><span class="line">target_link_libraries(turtle_tf_listener $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu16.04升级vscode</title>
      <link href="/2020/07/14/ubuntu16-04%E5%8D%87%E7%BA%A7vscode/"/>
      <url>/2020/07/14/ubuntu16-04%E5%8D%87%E7%BA%A7vscode/</url>
      
        <content type="html"><![CDATA[<p>ubuntu不同于windows，无法直接使用软件升级。<br>可以使用命令行来升级vscode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;vscode-update.azurewebsites.net&#x2F;latest&#x2F;linux-deb-x64&#x2F;stable -O &#x2F;tmp&#x2F;code_latest_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i &#x2F;tmp&#x2F;code_latest_amd64.deb</span><br></pre></td></tr></table></figure><p>本命令会将.deb文件包下载到 /tmp目录下。安装完成后，可以进入该目录进行删除</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己写srv文件vscode提示找不到文件</title>
      <link href="/2020/07/14/%E8%87%AA%E5%B7%B1%E5%86%99srv%E6%96%87%E4%BB%B6vscode%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6/"/>
      <url>/2020/07/14/%E8%87%AA%E5%B7%B1%E5%86%99srv%E6%96%87%E4%BB%B6vscode%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在学习古月居的教程中，提到，不同于消息通信，服务通信过程中服务的数据类型需要自己定义。节点并不提供标准服务类型。服务类型的定义文件一般是：*.srv为扩展名，且一般都放在功能包下的srv文件夹目录。ros中的服务数据可以通过srv文件进行语言无关的接口定义。一般写在功能包的srv目录。目的是client输入两个数，server返回这两个数相加的结果,下面是实践:</p><p>本地环境： ubuntu16.04 + ROS kinetic</p><p>1.在一个catkin_ws/src 下，创建一个pkg:<br><code>catkin_create_pkg learning_communication roscpp rospy</code><br>依赖会被默认写到功能包的CMakeLists.txt和package.xml中</p><p>2.创建自定义服务数据结构在learning_communication/srv 下创建 AddTwoInts.srv文件，文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><p>中间用’—‘隔开，上面的client的数据结构，下面是 server的数据结构</p><p><font color=red>注：定义好服务数据结构后，要想让服务类型在c++,python中使用，必须要做相应的编译与运行配置。<br>编译依赖message_generation<br>运行依赖message_runtime<br></font></p><p>本文为了方便演示，只说在vscode等下，找不到自定义数据结构的情况，所以server, client的源代码只包含头文件进行测试。</p><a id="more"></a><p>server.cpp的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ros&#x2F;ros.h&gt;</span><br><span class="line">#include &quot;learning_communication&#x2F;AddTwoInts.h&quot;            </span><br><span class="line">int main()&#123;&#125;</span><br></pre></td></tr></table></figure><p>client.cpp的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ros&#x2F;ros.h&gt;</span><br><span class="line">#include &quot;learning_communication&#x2F;AddTwoInts.h&quot;</span><br><span class="line">int main()&#123;&#125;</span><br></pre></td></tr></table></figure><font color=red>注： 以上的AddTwoInts.h 本来没有这个头文件，但根据作者的解释说，该头文件根据我们之前创建的服务数据类型AddTwoInts.srv自动创建，但是，后来经过测试，还是没有找到这个头文件，这里不报错，不知道是为什么。</font><p>接着打开package.xml (这里，这里打开的是包learning_communication下的package.xml, 后面的CMakeLists.txt也是， catkin_ws工作空间下的CMakeLists.txt是锁死了的，无法进行更改)<br>在<build_depend> 附近添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;   </span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;</span><br></pre></td></tr></table></figure><blockquote><p>根据上文所说，这里添加这两个编译与运行依赖<br>这里：原书下面写的是run_depend,经过测试，无法运行，会报错<br>这里添加的这两行目前还不清楚是什么意思，但是，发现，如果不自定义的话，package.xml这个文件是不需要进行修改的，只要在create_pkg 把需要添加的依赖全部添加到，这个xml会自动进行生成的.</p></blockquote><p>接着打开CMakeLists.txt<br>在一开始的find_package那里的末尾添加为这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  message_generation      &#x2F;&#x2F;根据上文所述，这里添加这个</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在find_package的下面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(FILES AddTwoInts.srv)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">    DEPENDENCIES</span><br><span class="line">    std_msgs      &#x2F;&#x2F;经过测试，这个也可以不要</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>再在末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_executable(server src&#x2F;server.cpp)</span><br><span class="line">add_dependencies(server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line">target_link_libraries(server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(client src&#x2F;client.cpp)</span><br><span class="line">add_dependencies(client $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line">target_link_libraries(client $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><font color=blue>注：查阅资料说，generate_messages 那段的作用是自动创建我们自定义的消息类型      *.msg与*.srv相对应的*.h. 且由于前面我们定义的srv那里有int64，使用了std_msgs。所以这里添加了std_msgs 但是，经过测试，这里注释了好像没有影响。</font><p>上述做完了，检验自定义的数据结构是否被识别<br><code>rossrv show learning_communication/AddTwoInts</code><br>若正常显示我们定义的结果就说明成功</p><p>以上就是c++ 在linux下的标准编译链接过程</p><blockquote><p>add_executable(server src/server.cpp)   //这个意思是用于设置需要编译的代码和生成的可执行文件(cpp)，第一个参数是希望生成的可执行文件名称，后面的是需要编译的文件路径</p></blockquote><blockquote><p>add_dependencies(server ${PROJECT_NAME}_gencpp) //用于设置依赖，我们在许多应用中，需要定义与语言无关的消息类型，消息类型会在编译过程中产生相应语言的代码，生成python就是_genpy</p></blockquote><blockquote><p>target_link_libraries(server ${catkin_LIBRARIES})  //用于设置链接库，有时候需要第三方的库函数。 第一个跟上面一样，是可执行文件的名字。 第二个是需要链接的库，这里不需要第三方库，使用默认链接库即可。</p></blockquote><p>这样弄了后， <code>catkin_make</code> 就会成功，接着打开vscode， 就不会提示找不到文件了.</p><p>以下是完整代码<br><strong>server.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;ros&#x2F;ros.h&quot;</span><br><span class="line">#include &quot;learning_communication&#x2F;AddTwoInts.h&quot;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; service回调函数，输入参数req，输出参数res这里目前的运行机制还不是特别明白，为什么add输入参数啥也没有，为什么这里就接收到了?</span><br><span class="line">bool add(learning_communication::AddTwoInts::Request  &amp;req,</span><br><span class="line">         learning_communication::AddTwoInts::Response &amp;res)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 将输入参数中的请求数据相加，结果放到应答变量中</span><br><span class="line">  res.sum &#x3D; req.a + req.b;</span><br><span class="line">  ROS_INFO(&quot;request: x&#x3D;%ld, y&#x3D;%ld&quot;, (long int)req.a, (long int)req.b);</span><br><span class="line">  ROS_INFO(&quot;sending back response: [%ld]&quot;, (long int)res.sum);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;计算成功后，返回true</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; ROS节点初始化</span><br><span class="line">  ros::init(argc, argv, &quot;add_two_ints_server&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 创建节点句柄</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 创建一个名为add_two_ints的server，注册回调函数add(),这个服务在ROS网络中医名称作为唯一标识，任何节点都可以通关这个名字来使用这个服务.</span><br><span class="line">  然后问题跟上面的一样，为什么这里add里面什么都没有输入，但是,add函数实现的时候，却有参数？</span><br><span class="line">  ros::ServiceServer service &#x3D; n.advertiseService(&quot;add_two_ints&quot;, add);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 循环等待回调函数</span><br><span class="line">  ROS_INFO(&quot;Ready to add two ints.&quot;);</span><br><span class="line">  ros::spin();   &#x2F;&#x2F;这里不能使用ros::spinonce()这样的话，这个程序根本不会执行下去</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>client.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &quot;ros&#x2F;ros.h&quot;</span><br><span class="line">#include &quot;learning_communication&#x2F;AddTwoInts.h&quot;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; ROS节点初始化</span><br><span class="line">  ros::init(argc, argv, &quot;add_two_ints_client&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 从终端命令行获取两个加数</span><br><span class="line">  &#x2F;&#x2F;如果输入格式不是 rosrun learning_communication 3 5这种格式的话</span><br><span class="line">  if (argc !&#x3D; 3)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO(&quot;usage: add_two_ints_client X Y&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 创建节点句柄</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  &#x2F;*创建一个client，请求add_two_int service，service消息类型是learning_communication::AddTwoInts</span><br><span class="line">  *&#x2F;</span><br><span class="line">  ros::ServiceClient client &#x3D; n.serviceClient&lt;learning_communication::AddTwoInts&gt;(&quot;add_two_ints&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;* 创建learning_communication::AddTwoInts类型的service消息</span><br><span class="line">     定义了一个learning_communication::AddTwoInts 服务类型的对象，该对象的成员就是先前定义的a, b, sum这些。我们将待请求的数据填充到数据成员a,b中，经过server的计算，sum就会被自动进行填充</span><br><span class="line">  *&#x2F;</span><br><span class="line">  learning_communication::AddTwoInts srv;</span><br><span class="line">  srv.request.a &#x3D; atoll(argv[1]);</span><br><span class="line">  srv.request.b &#x3D; atoll(argv[2]);</span><br><span class="line">  </span><br><span class="line">  &#x2F;* 发布service请求，等待加法运算的应答结果</span><br><span class="line">     也就是使用前面的client 实例，调用call方法来向service发起请求，传入的数据参数就是srv</span><br><span class="line">  *&#x2F;</span><br><span class="line">  if (client.call(srv))</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO(&quot;Sum: %ld&quot;, (long int)srv.response.sum);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(&quot;Failed to call service add_two_ints&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>一个node可以发布，接收多个消息，服务。所以对于client来说，请求的是服务名，而不是服务节点的名字。所以这里ros::ServiceClient client = n.serviceClient&lt;learning_communication::AddTwoInts&gt;(&quot;add_two_ints&quot;);是创建一个client对象，用来向名字叫add_two_ints的服务发起请求。</code></pre><blockquote><p>注： 在client.cpp 中的&gt;  if (argc != 3)<br>在c系列语言中 argc 是输入的参数个数， argv是字串串指针<br>如果这样输入: rosrun learning_communication client 3 5<br>那么argc=3<br>第一个参数是 ***/catkin_ws/devel/lib/learning_communication/client<br>第二个参数是 3<br>第三个参数是5<br>要想打印的话可以使用: <code>printf(&quot;%s&quot;,argv[1])</code></p></blockquote><p>补充：linux 下c++的atoi, atol, atoll, atof</p><blockquote><p>atoi 将字符串转化为int类型变量<br>atol 将字符串转换为long类型变量<br>atoll 将字符串转化为long long 类型变量<br>atof 将字符串转化为double类型变量<br>详细使用见: <a href="https://my.oschina.net/Tsybius2014/blog/338234?p=1" target="_blank" rel="noopener">linux下上述的调用示例</a></p></blockquote><p>运行前需要先: </p><blockquote><p>cd catkin_ws<br>source devel/setup.bash</p></blockquote><p>运行结果，server会一直等待，client执行一次就会终止<br><img src="/image/srv.png" alt="运行结果图"></p><p>大致流程图<br><img src="/image/server-client-process.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
            <tag> srv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装win10-ubuntu双系统</title>
      <link href="/2020/07/13/%E5%AE%89%E8%A3%85win10-ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/07/13/%E5%AE%89%E8%A3%85win10-ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>目标：安装win10,ubuntu16.04双系统</p><a id="more"></a><p>ubuntu只支持gpt格式，而启动方式一般有：</p><blockquote><p>legacy<br>uefi<br>legacy+uefi 混合模式</p></blockquote><p>而ubuntu系统，只支持uefi模式，所以bios中，只能设置:uefi,legacy+uefi 混合模式所</p><p>而win10一般的模式时: uefi+gpt<br>如果安装的时候，先安装的win10硬盘分区的时候，格式是mbr, 那么在bios中只能设置为legacy, 这样的话，即使安装了ubuntu，这下，这两个就不能同时启动了。</p><p>安装步骤：</p><ol><li>进入iso安装步骤，进入到<br><img src="/image/ubuntu-win10-1.jpg" alt=""></li></ol><p>找到空闲分区<br>/swap : 设置为与内存一致 逻辑分区 交换空间</p><p>efi  :800m  逻辑分区 efi系统分区</p><p>/:     安装系统和软件 主分区 ex4文件系统</p><p>/home  :剩下的所有 相当于其他盘 可以不要 逻辑分区<br>ex4文件系统</p><p>下面的安装启动项的位置为efi前面的sd号</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode配置ros时提示找不到ros/ros.h</title>
      <link href="/2020/07/13/vscode%E9%85%8D%E7%BD%AEros%E6%97%B6%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0ros-ros-h/"/>
      <url>/2020/07/13/vscode%E9%85%8D%E7%BD%AEros%E6%97%B6%E6%8F%90%E7%A4%BA%E6%89%BE%E4%B8%8D%E5%88%B0ros-ros-h/</url>
      
        <content type="html"><![CDATA[<p>在安装vscode后，打开一个catkin_ws后#include&lt;ros/ros.h&gt;<br>经常会出现找不到ros/ros.h的情况<br>解决办法：<br>在vscode中打开c_cpp_properties.json<br>在includePath中添加”/opt/ros/kinetic/include/*”   ，也就是本地安装的ros路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vscode </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用system备份ubuntu生成iso镜像</title>
      <link href="/2020/07/13/%E4%BD%BF%E7%94%A8system%E5%A4%87%E4%BB%BDubuntu%E7%94%9F%E6%88%90iso%E9%95%9C%E5%83%8F/"/>
      <url>/2020/07/13/%E4%BD%BF%E7%94%A8system%E5%A4%87%E4%BB%BDubuntu%E7%94%9F%E6%88%90iso%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>本地环境： ubuntu16.04<br>1 安装Systemback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo add-apt-repository ppa:nemh&#x2F;systemback</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install systemback unionfs-fuse</span><br></pre></td></tr></table></figure><a id="more"></a><p>2 使用Systemback生成镜像文件<br>(1)打开软件，输入密码<br><img src="/image/live_system_create.png" alt="live_system_create"></p><p>(2)勾选左侧的include the user data files（包含用户数据文件），这样自己主文件夹内的文件都会被包含在系统镜像中。很多相关的程序的配置文件都是保存在主文件夹内的。Working Directory是设置工作目录，程序运行时产生的临时文件都会被保存在这里。所以一定要保证这里有足够的存储空间。</p><p><img src="/image/create_new.png" alt="create_new"></p><p>3 压缩系统镜像<br>Systemback在使用时会发现当生成的sblive文件大于4G的时候是没有办法生成iso文件的。这是由于iso文件自身的限制，iso9600对于文件有限制，单个文件不能超过2G，总的iso文件不能超过4G。<br>所以当上面生成的系统镜像如果大于4G，不能直接转存为iso文件，就要使用采用udf文件系统压缩再转存为光盘文件，下面就是具体的解决方法了。<br>进入计算机的home文件夹，可以看到这里面有一个systemback生成的文件 ****.sblive</p><p>3.1 解压 .sblive 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir sblive</span><br><span class="line">tar -xf &#x2F;home&#x2F;systemback_live_2018-10-15.sblive -C sblive   &#x2F;&#x2F;这里换成你自己的文件名</span><br></pre></td></tr></table></figure><p>3.2重命名syslinux 至 isolinux：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv sblive&#x2F;syslinux&#x2F;syslinux.cfg sblive&#x2F;syslinux&#x2F;isolinux.cfg</span><br><span class="line">mv sblive&#x2F;syslinux sblive&#x2F;isolinux</span><br></pre></td></tr></table></figure><p>3.3 安装 cdtools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install aria2</span><br><span class="line"></span><br><span class="line">aria2c -s 10 https:&#x2F;&#x2F;nchc.dl.sourceforge.net&#x2F;project&#x2F;cdrtools&#x2F;alpha&#x2F;cdrtools-3.02a07.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvf cdrtools-3.02a07.tar.gz</span><br><span class="line"></span><br><span class="line">cd cdrtools-3.02</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>3.4生成ISO文件：<br><code>/opt/schily/bin/mkisofs -iso-level 3 -r -V sblive -cache-inodes -J -l -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -c isolinux/boot.cat -o sblive.iso sblive</code><br>同样的，这里名字改成你自己的文件名</p><p>3.5最终生成iso镜像<br><img src="/image/iso.png" alt="生成了iso镜像"></p><p>现在的镜像就可以直接进行安装了，但是，经过测试发现，这样备份的系统，如果原来已经安装了nvidia，wifi等驱动，那么这里也会进行备份，然后就会造成换了新电脑，导致循环进入桌面，猜测是由于驱动的不兼容造成的，所以，最好的结果还是在备份系统之前，最好不要安装显卡驱动等，避免造成不必要的麻烦。</p><p>参考链接：<a href="https://www.cnblogs.com/Pan-xi-yi/p/11830789.html" target="_blank" rel="noopener">目前来看这个行得通</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 备份 </tag>
            
            <tag> iso </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo以及markdown常见语法</title>
      <link href="/2020/07/13/hexo%E4%BB%A5%E5%8F%8Amarkdown%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/13/hexo%E4%BB%A5%E5%8F%8Amarkdown%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p><code>hexo g</code> 生成<br><code>hexo s</code> 预览</p><p>定义多个标签<br><code>tags: [,,,]</code></p><a id="more"></a><h1 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题 </span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>插入图片：<br>1.本地图片<br>在与_posts同级的目录，新建一个image文件夹专门用来存储image，拷贝图片到该路径<br>格式: <code>![文件描述](/image/***)</code></p><p>更改字体颜色：</p><blockquote><p><font color=red>****</font></p></blockquote><blockquote><p>多行文本框<br>每行开头空四格<br>  我在北京<br>参看：<a href="http://xianbai.me/learn-md/index.html" target="_blank" rel="noopener">markdown详细资料</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下通过hexo搭建github博客(无域名)</title>
      <link href="/2020/07/13/windows%E4%B8%8B%E9%80%9A%E8%BF%87hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2-%E6%97%A0%E5%9F%9F%E5%90%8D/"/>
      <url>/2020/07/13/windows%E4%B8%8B%E9%80%9A%E8%BF%87hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2-%E6%97%A0%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装git和node-js"><a href="#1-安装git和node-js" class="headerlink" title="1.安装git和node.js"></a>1.安装<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">node.js</a></h1><h1 id="2-配置-ssh-keys"><a href="#2-配置-ssh-keys" class="headerlink" title="2.配置 ssh keys"></a>2.配置 ssh keys</h1><h2 id="1-检查电脑是否有key"><a href="#1-检查电脑是否有key" class="headerlink" title="(1)检查电脑是否有key"></a>(1)检查电脑是否有key</h2><p><code>$ cd ~/.ssh</code><br>如果显示”no such file”，则说明没有</p><h2 id="2-生成新的ssh-key"><a href="#2-生成新的ssh-key" class="headerlink" title="(2)生成新的ssh key"></a>(2)生成新的ssh key</h2><p><code>$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</code><br>一路回车</p><a id="more"></a><h2 id="3-添加ssh-key-到github"><a href="#3-添加ssh-key-到github" class="headerlink" title="(3)添加ssh key 到github"></a>(3)添加ssh key 到github</h2><p>打开上述路径复制id_rsa.pub的内容，登陆github(Settings—SSH and GPG keys—New SSH key)</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="(4)测试"></a>(4)测试</h2><p><code>$ ssh -T git@github.com</code><br>然后输入yes回车，如果有设置密码的话会提示输入密码，没有的则跳过。<br>最后出现successful就成功了</p><h2 id="5-完善个人信息"><a href="#5-完善个人信息" class="headerlink" title="(5)完善个人信息"></a>(5)完善个人信息</h2><p><code>$ git config --global user.name &quot;wuyalan&quot;//输入注册时的username$ git config --global user.email  &quot;alan.wyl@foxmail.com&quot;//填写注册邮箱</code></p><h1 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h1><p><code>$ npm install -g hexo-cli</code><br>通过查看版本号查看是否安装成功<br><code>$ hexo version</code></p><h1 id="4-创建工作目录"><a href="#4-创建工作目录" class="headerlink" title="4.创建工作目录"></a>4.创建工作目录</h1><p>命名一个工作路径<br><code>$ hexo init</code> 这里会创建hexo需要的所有文件到这个文件路径</p><p>安装依赖包<br><code>npm install</code></p><p>确保git部署<br><code>$ npm install hexo-deployer-git --save</code></p><h1 id="5-查看，更新，上传"><a href="#5-查看，更新，上传" class="headerlink" title="5.查看，更新，上传"></a>5.查看，更新，上传</h1><p><code>$ hexo g  //每次进行相应改动都要hexo g 生成一下</code><br><code>$ hexo s  //启动服务预览</code><br>此时在浏览器中输入：<code>localhost:4000</code>可以进行预览<br><code>$ hexo g -d</code> 上传到github上</p><h1 id="6-更改主题"><a href="#6-更改主题" class="headerlink" title="6.更改主题"></a>6.更改主题</h1><p>在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网</a><br>找到一个主题后，进入其github目录,复制clone<br>打开终端：<code>gic clone ****  themes/主题名字</code><br>clone完毕后<br>进入项目，找到_config.yml 搜索theme 将其改成下载的样式名字，在看效果</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/80142778" target="_blank" rel="noopener">知乎github+hexo搭建个人博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gsdgg</title>
      <link href="/2020/07/13/gsdgg/"/>
      <url>/2020/07/13/gsdgg/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 456 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/07/13/test/"/>
      <url>/2020/07/13/test/</url>
      
        <content type="html"><![CDATA[<p>测试时中山东莞深度</p><p><code>dfsdgsg int main</code><br>$\alpha+\beta=\gamma$</p><p>$\alpha+\beta=\gamma$</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 123 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/13/hello-world/"/>
      <url>/2020/07/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 123 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
